{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  {% csrf_token %}
  <meta name="csrf-token" content="{{ csrf_token }}">
  <title>{% block title %} SALES FORECASTING {% endblock %}</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <style>
    :root {
      --primary: #1abc9c;
      --secondary: #3498db;
      --dark: #2c3e50;
      --gray: #7f8c8d;
      --light-gray: #ecf0f1;
      --white: #ffffff;
      --success: #2ecc71;
      --warning: #f39c12;
      --error: #e74c3c;
      --purple: #9b59b6;
      --info: #3498db;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f5f7fa;
      color: var(--dark);
    }
    
    .forecast-container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .forecast-header {
      margin-bottom: 30px;
    }
    
    .forecast-header h1 {
      font-family: 'Montserrat', sans-serif;
      font-weight: 700;
      color: var(--dark);
      font-size: 2rem;
      margin-bottom: 8px;
    }
    
    .forecast-header p {
      color: var(--gray);
      font-size: 1.05rem;
    }
    
    .controls-section {
      background: var(--white);
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
      margin-bottom: 30px;
    }
    
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
    }
    
    .control-group label {
      font-weight: 500;
      color: var(--dark);
      margin-bottom: 8px;
      font-size: 0.95rem;
    }
    
    .control-group select,
    .control-group input {
      padding: 10px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      font-family: 'Roboto', sans-serif;
      font-size: 0.95rem;
    }
    
    .control-group select:focus,
    .control-group input:focus {
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 2px rgba(26, 188, 156, 0.2);
    }
    
    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-family: 'Roboto', sans-serif;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
    }
    
    .btn-primary {
      background-color: var(--primary);
      color: var(--white);
    }
    
    .btn-primary:hover {
      background-color: #16a085;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(26, 188, 156, 0.3);
    }
    
    .btn-secondary {
      background-color: var(--secondary);
      color: var(--white);
    }
    
    .btn-secondary:hover {
      background-color: #2980b9;
    }
    
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .metric-card {
      background: var(--white);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
      display: flex;
      align-items: center;
      gap: 20px;
      transition: transform 0.3s, box-shadow 0.3s;
    }
    
    .metric-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.12);
    }
    
    .metric-icon {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      flex-shrink: 0;
    }
    
    .metric-icon.primary { background: linear-gradient(135deg, #d1f2eb 0%, var(--primary) 100%); color: #16a085; }
    .metric-icon.secondary { background: linear-gradient(135deg, #e3f2fd 0%, var(--secondary) 100%); color: #1565c0; }
    .metric-icon.success { background: linear-gradient(135deg, #e8f5e9 0%, var(--success) 100%); color: #2e7d32; }
    .metric-icon.warning { background: linear-gradient(135deg, #fff3e0 0%, var(--warning) 100%); color: #e65100; }
    .metric-icon.purple { background: linear-gradient(135deg, #f3e5f5 0%, var(--purple) 100%); color: #6a1b9a; }
    
    .metric-content { flex: 1; }
    
    .metric-label {
      font-size: 0.85rem;
      color: var(--gray);
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }
    
    .metric-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--dark);
      font-family: 'Montserrat', sans-serif;
    }
    
    .metric-change {
      font-size: 0.85rem;
      margin-top: 5px;
    }
    
    .metric-change.positive { color: var(--success); }
    .metric-change.negative { color: var(--error); }
    .metric-change.neutral { color: var(--gray); }
    
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .chart-card {
      background: var(--white);
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }
    
    .chart-card.wide { grid-column: span 2; }
    
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid var(--light-gray);
    }
    
    .chart-title {
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      color: var(--dark);
      font-size: 1.3rem;
    }
    
    .chart-subtitle {
      color: var(--gray);
      font-size: 0.9rem;
      margin-top: 5px;
    }
    
    .chart-container {
      position: relative;
      height: 350px;
    }
    
    .insights-section {
      background: var(--white);
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
      margin-bottom: 30px;
    }
    
    .insights-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid var(--light-gray);
    }
    
    .insights-header h2 {
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      color: var(--dark);
      font-size: 1.4rem;
    }
    
    .insights-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
    }
    
    .insight-card {
      padding: 20px;
      border-radius: 8px;
      border-left: 4px solid var(--primary);
      background: #f8f9fa;
    }
    
    .insight-card.warning { border-left-color: var(--warning); }
    .insight-card.success { border-left-color: var(--success); }
    .insight-card.info { border-left-color: var(--info); }
    
    .insight-title {
      font-weight: 600;
      color: var(--dark);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .insight-text {
      color: var(--gray);
      line-height: 1.6;
    }
    
    .forecast-table-section {
      background: var(--white);
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
      margin-bottom: 30px;
    }
    
    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid var(--light-gray);
    }
    
    .table-title {
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      color: var(--dark);
      font-size: 1.3rem;
    }
    
    .data-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .data-table th {
      background-color: var(--dark);
      color: var(--white);
      padding: 12px 15px;
      text-align: left;
      font-weight: 500;
      font-size: 0.9rem;
    }
    
    .data-table td {
      padding: 12px 15px;
      border-bottom: 1px solid var(--light-gray);
      color: var(--dark);
      font-size: 0.9rem;
    }
    
    .data-table tr:hover {
      background-color: rgba(26, 188, 156, 0.05);
    }
    
    .accuracy-badge {
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      display: inline-block;
    }
    
    .accuracy-badge.high { background-color: #d4edda; color: #155724; }
    .accuracy-badge.medium { background-color: #fff3cd; color: #856404; }
    .accuracy-badge.low { background-color: #f8d7da; color: #721c24; }
    
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    .spinner {
      border: 5px solid var(--light-gray);
      border-top: 5px solid var(--primary);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .no-data-message {
      text-align: center;
      padding: 60px 20px;
      color: var(--gray);
    }
    
    .no-data-message i {
      font-size: 4rem;
      color: #bdc3c7;
      margin-bottom: 20px;
      display: block;
    }
    
    .no-data-message h3 {
      font-family: 'Montserrat', sans-serif;
      margin-bottom: 10px;
      color: var(--dark);
    }
    
    @media (max-width: 1200px) {
      .charts-grid { grid-template-columns: 1fr; }
      .chart-card.wide { grid-column: span 1; }
    }
    
    @media (max-width: 768px) {
      .metrics-grid { grid-template-columns: 1fr; }
      .controls-grid { grid-template-columns: 1fr; }
      .insights-grid { grid-template-columns: 1fr; }
      .chart-container { height: 250px; }
    }
  </style>
</head>

<body>
  <div class="forecast-container">
    <div class="forecast-header">
      <h1><i class="fas fa-chart-line"></i> Sales Forecasting & Analysis</h1>
      <p>Predictive analytics and insights for inventory planning</p>
    </div>
    
    <!-- Controls Section -->
    <div class="controls-section">
      <div class="controls-grid">
        <div class="control-group">
          <label>Forecast Period</label>
          <select id="forecastPeriod">
            <option value="1">Next 1 Month</option>
            <option value="3" selected>Next 3 Months</option>
            <option value="6">Next 6 Months</option>
            <option value="12">Next 12 Months</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>Analysis Type</label>
          <select id="analysisType">
            <option value="overall" selected>Overall Sales</option>
            <option value="category">By Category</option>
            <option value="item">By Item</option>
            <option value="location">By Location</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>Historical Data Range</label>
          <select id="historicalRange">
            <option value="3">Last 3 Months</option>
            <option value="6" selected>Last 6 Months</option>
            <option value="12">Last 12 Months</option>
            <option value="all">All Available Data</option>
          </select>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="btn btn-primary" onclick="generateForecast()">
          <i class="fas fa-magic"></i> Generate Forecast
        </button>
        <button class="btn btn-secondary" onclick="exportForecast()">
          <i class="fas fa-download"></i> Export Report
        </button>
      </div>
    </div>
    
    <!-- Key Metrics -->
    <div class="metrics-grid">
      <div class="metric-card">
        <div class="metric-icon primary">
          <i class="fas fa-chart-line"></i>
        </div>
        <div class="metric-content">
          <div class="metric-label">Predicted Sales (Next Period)</div>
          <div class="metric-value" id="predictedSales">KSH 0.00</div>
          <div class="metric-change neutral" id="predictionConfidence">Calculating...</div>
        </div>
      </div>
      
      <div class="metric-card">
        <div class="metric-icon success">
          <i class="fas fa-percentage"></i>
        </div>
        <div class="metric-content">
          <div class="metric-label">Average Growth Rate</div>
          <div class="metric-value" id="growthRate">0%</div>
          <div class="metric-change neutral" id="growthTrend">Month-over-month</div>
        </div>
      </div>
      
      <div class="metric-card">
        <div class="metric-icon warning">
          <i class="fas fa-box"></i>
        </div>
        <div class="metric-content">
          <div class="metric-label">Recommended Stock Level</div>
          <div class="metric-value" id="stockLevel">0</div>
          <div class="metric-change neutral" id="stockDays">Units needed</div>
        </div>
      </div>
      
      <div class="metric-card">
        <div class="metric-icon secondary">
          <i class="fas fa-calendar-alt"></i>
        </div>
        <div class="metric-content">
          <div class="metric-label">Peak Sales Period</div>
          <div class="metric-value" id="peakPeriod" style="font-size: 1.2rem;">Loading...</div>
          <div class="metric-change neutral" id="peakValue">Highest sales expected</div>
        </div>
      </div>
      
      <div class="metric-card">
        <div class="metric-icon purple">
          <i class="fas fa-crosshairs"></i>
        </div>
        <div class="metric-content">
          <div class="metric-label">Forecast Accuracy</div>
          <div class="metric-value" id="forecastAccuracy">0%</div>
          <div class="metric-change neutral" id="accuracyNote">Based on historical data</div>
        </div>
      </div>
    </div>
    
    <!-- Charts -->
    <div class="charts-grid">
      <div class="chart-card wide">
        <div class="chart-header">
          <div>
            <div class="chart-title">Sales Forecast vs Historical</div>
            <div class="chart-subtitle">Predicted sales with confidence intervals</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="forecastChart"></canvas>
        </div>
      </div>
      
      <div class="chart-card">
        <div class="chart-header">
          <div>
            <div class="chart-title">Sales Seasonality</div>
            <div class="chart-subtitle">Monthly patterns</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="seasonalityChart"></canvas>
        </div>
      </div>
      
      <div class="chart-card">
        <div class="chart-header">
          <div>
            <div class="chart-title">Trend Analysis</div>
            <div class="chart-subtitle">Growth trajectory</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="trendChart"></canvas>
        </div>
      </div>
      
      <div class="chart-card">
        <div class="chart-header">
          <div>
            <div class="chart-title">Top Products Forecast</div>
            <div class="chart-subtitle">Expected best sellers</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="topProductsChart"></canvas>
        </div>
      </div>
      
      <div class="chart-card">
        <div class="chart-header">
          <div>
            <div class="chart-title">Category Performance</div>
            <div class="chart-subtitle">Revenue distribution</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="categoryChart"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Insights Section -->
    <div class="insights-section">
      <div class="insights-header">
        <i class="fas fa-lightbulb" style="color: var(--warning); font-size: 1.5rem;"></i>
        <h2>AI-Powered Insights & Recommendations</h2>
      </div>
      <div class="insights-grid" id="insightsContainer">
        <div class="no-data-message">
          <i class="fas fa-chart-bar"></i>
          <h3>Generate a forecast to see insights</h3>
          <p>Click "Generate Forecast" above to get AI-powered recommendations</p>
        </div>
      </div>
    </div>
    
    <!-- Forecast Details Table -->
    <div class="forecast-table-section">
      <div class="table-header">
        <div class="table-title">
          <i class="fas fa-table"></i>
          Detailed Forecast Breakdown
        </div>
      </div>
      <table class="data-table">
        <thead>
          <tr>
            <th>Period</th>
            <th>Predicted Sales</th>
            <th>Lower Bound</th>
            <th>Upper Bound</th>
            <th>Confidence</th>
            <th>Recommended Action</th>
          </tr>
        </thead>
        <tbody id="forecastTableBody">
          <tr>
            <td colspan="6" class="no-data-message" style="padding: 40px;">
              <i class="fas fa-info-circle"></i>
              <p>Generate a forecast to see detailed predictions</p>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
  
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
    <p>Analyzing data and generating forecast...</p>
  </div>

  <script>
    console.log('ðŸ“Š Sales Forecasting Module Loading...');
    
    let forecastData = {
      historical: [],
      salesDetails: [],
      inventory: []
    };
    
    let charts = {};
    
    function getCSRFToken() {
      const metaTag = document.querySelector('meta[name="csrf-token"]');
      if (metaTag) return metaTag.getAttribute('content');
      const cookies = document.cookie.split(';');
      for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'csrftoken') return value;
      }
      return null;
    }
    
    function formatNumber(num) {
      if (isNaN(num)) return '0.00';
      return num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }
    
    function parseDate(dateStr) {
      if (!dateStr) return new Date();
      const [day, month, year] = dateStr.split('/');
      return new Date(year, month - 1, day);
    }
    
    function showLoading() { document.getElementById('loadingOverlay').style.display = 'flex'; }
    function hideLoading() { document.getElementById('loadingOverlay').style.display = 'none'; }
    
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ðŸš€ Initializing Sales Forecasting...');
      loadHistoricalData();
    });
    
    async function loadHistoricalData() {
      showLoading();
      try {
        const [salesResponse, detailsResponse, inventoryResponse] = await Promise.all([
          fetch('/api/sales/', {
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
            credentials: 'same-origin'
          }),
          fetch('/api/dashboard/sales-details/', {
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
            credentials: 'same-origin'
          }),
          fetch('/api/inventory/all/', {
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
            credentials: 'same-origin'
          })
        ]);
        
        const salesResult = await salesResponse.json();
        const detailsResult = await detailsResponse.json();
        const inventoryResult = await inventoryResponse.json();
        
        forecastData.historical = salesResult.success ? (salesResult.data || []) : [];
        forecastData.salesDetails = detailsResult.success ? (detailsResult.data || []) : [];
        forecastData.inventory = inventoryResult.success ? (inventoryResult.data || []) : [];
        
        console.log('âœ… Data loaded:', {
          sales: forecastData.historical.length,
          details: forecastData.salesDetails.length,
          inventory: forecastData.inventory.length
        });
        
        if (forecastData.historical.length > 0) {
          generateForecast();
        } else {
          hideLoading();
          showNoDataMessage();
        }
      } catch (error) {
        console.error('âŒ Error loading data:', error);
        hideLoading();
        alert('Error loading historical data. Please check console.');
      }
    }
    
    function generateForecast() {
      if (forecastData.historical.length === 0) {
        alert('No historical sales data available for forecasting');
        return;
      }
      
      showLoading();
      
      try {
        const forecastPeriod = parseInt(document.getElementById('forecastPeriod').value);
        const analysisType = document.getElementById('analysisType').value;
        const historicalRange = document.getElementById('historicalRange').value;
        
        const filteredData = filterHistoricalData(historicalRange);
        const monthlyData = aggregateByMonth(filteredData);
        const forecast = calculateForecast(monthlyData, forecastPeriod);
        const insights = generateInsights(monthlyData, forecast);
        
        updateMetrics(forecast, monthlyData);
        renderCharts(monthlyData, forecast);
        displayInsights(insights);
        populateForecastTable(forecast);
        
        console.log('âœ… Forecast generated successfully');
      } catch (error) {
        console.error('âŒ Error generating forecast:', error);
        alert('Error generating forecast. Please try again.');
      } finally {
        hideLoading();
      }
    }
    
    function filterHistoricalData(range) {
      if (range === 'all') return forecastData.historical;
      
      const months = parseInt(range);
      const cutoffDate = new Date();
      cutoffDate.setMonth(cutoffDate.getMonth() - months);
      
      return forecastData.historical.filter(sale => {
        const saleDate = parseDate(sale.date);
        return saleDate >= cutoffDate;
      });
    }
    
    function aggregateByMonth(sales) {
      const monthly = {};
      
      sales.forEach(sale => {
        const date = parseDate(sale.date);
        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        
        if (!monthly[key]) {
          monthly[key] = {
            date: new Date(date.getFullYear(), date.getMonth(), 1),
            revenue: 0,
            orders: 0
          };
        }
        
        monthly[key].revenue += parseFloat(sale.total_amount) || 0;
        monthly[key].orders += 1;
      });
      
      return Object.values(monthly).sort((a, b) => a.date - b.date);
    }
    
    function calculateForecast(historical, periods) {
      if (historical.length < 2) {
        return generateDefaultForecast(periods);
      }
      
      const revenues = historical.map(m => m.revenue);
      const trend = calculateLinearTrend(revenues);
      const seasonality = calculateSeasonality(revenues);
      
      const forecast = [];
      const lastDate = historical[historical.length - 1].date;
      
      for (let i = 1; i <= periods; i++) {
        const nextDate = new Date(lastDate);
        nextDate.setMonth(nextDate.getMonth() + i);
        
        const trendValue = trend.slope * (historical.length + i) + trend.intercept;
        const seasonalIndex = seasonality[(nextDate.getMonth()) % 12];
        const baseValue = trendValue * seasonalIndex;
        
        const noise = baseValue * 0.1;
        
        forecast.push({
          date: nextDate,
          predicted: Math.max(0, baseValue),
          lower: Math.max(0, baseValue - noise),
          upper: baseValue + noise,
          confidence: calculateConfidence(historical.length, i)
        });
      }
      
      return forecast;
    }
    
    function calculateLinearTrend(data) {
      const n = data.length;
      const sumX = (n * (n - 1)) / 2;
      const sumY = data.reduce((a, b) => a + b, 0);
      const sumXY = data.reduce((sum, y, x) => sum + x * y, 0);
      const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
      
      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      
      return { slope, intercept };
    }
    
    function calculateSeasonality(data) {
      const seasonal = new Array(12).fill(1);
      
      if (data.length < 12) return seasonal;
      
      const avgPerMonth = {};
      const overall = data.reduce((a, b) => a + b, 0) / data.length;
      
      data.forEach((value, i) => {
        const month = i % 12;
        if (!avgPerMonth[month]) avgPerMonth[month] = [];
        avgPerMonth[month].push(value);
      });
      
      Object.keys(avgPerMonth).forEach(month => {
        const avg = avgPerMonth[month].reduce((a, b) => a + b, 0) / avgPerMonth[month].length;
        seasonal[month] = overall > 0 ? avg / overall : 1;
      });
      
      return seasonal;
    }
    
    function calculateConfidence(historicalLength, periodsAhead) {
      const base = Math.min(historicalLength / 12, 1);
      const decay = Math.exp(-periodsAhead / 6);
      return Math.round(base * decay * 100);
    }
    
    function generateDefaultForecast(periods) {
      const forecast = [];
      const today = new Date();
      
      for (let i = 1; i <= periods; i++) {
        const nextDate = new Date(today);
        nextDate.setMonth(nextDate.getMonth() + i);
        
        forecast.push({
          date: nextDate,
          predicted: 0,
          lower: 0,
          upper: 0,
          confidence: 0
        });
      }
      
      return forecast;
    }
    
    function updateMetrics(forecast, historical) {
      const nextPeriodSales = forecast[0]?.predicted || 0;
      document.getElementById('predictedSales').textContent = 'KSH ' + formatNumber(nextPeriodSales);
      document.getElementById('predictionConfidence').textContent = `${forecast[0]?.confidence || 0}% confidence`;
      
      const growthRates = [];
      for (let i = 1; i < historical.length; i++) {
        const rate = ((historical[i].revenue - historical[i-1].revenue) / historical[i-1].revenue) * 100;
        if (isFinite(rate)) growthRates.push(rate);
      }
      const avgGrowth = growthRates.length > 0 ? growthRates.reduce((a, b) => a + b, 0) / growthRates.length : 0;
      document.getElementById('growthRate').textContent = avgGrowth.toFixed(1) + '%';
      document.getElementById('growthTrend').textContent = avgGrowth >= 0 ? 'Growing' : 'Declining';
      document.getElementById('growthTrend').className = avgGrowth >= 0 ? 'metric-change positive' : 'metric-change negative';
      
      const itemSales = {};
      forecastData.salesDetails.forEach(detail => {
        const itemId = detail.item_id || detail.item_name;
        itemSales[itemId] = (itemSales[itemId] || 0) + (parseInt(detail.quantity_sold) || 0);
      });
      
      const avgMonthlySales = historical.length > 0 ? 
        historical.reduce((sum, m) => sum + m.orders, 0) / historical.length : 0;
      const recommendedStock = Math.ceil(avgMonthlySales * 1.5);
      document.getElementById('stockLevel').textContent = recommendedStock;
      document.getElementById('stockDays').textContent = '~45 days supply';
      
      const peakMonth = forecast.reduce((max, curr) => 
        curr.predicted > max.predicted ? curr : max, forecast[0]);
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      document.getElementById('peakPeriod').textContent = 
        monthNames[peakMonth.date.getMonth()] + ' ' + peakMonth.date.getFullYear();
      document.getElementById('peakValue').textContent = 'KSH ' + formatNumber(peakMonth.predicted);
      
      const accuracy = historical.length >= 3 ? 
        Math.min(95, 60 + (historical.length * 2)) : 50;
      document.getElementById('forecastAccuracy').textContent = accuracy + '%';
      document.getElementById('accuracyNote').textContent = 
        historical.length >= 6 ? 'High confidence' : 'Limited historical data';
    }
    
    function renderCharts(historical, forecast) {
      renderForecastChart(historical, forecast);
      renderSeasonalityChart(historical);
      renderTrendChart(historical, forecast);
      renderTopProductsChart();
      renderCategoryChart();
    }
    
    function renderForecastChart(historical, forecast) {
      const ctx = document.getElementById('forecastChart');
      if (charts.forecast) charts.forecast.destroy();
      
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
      const historicalLabels = historical.map(m => 
        monthNames[m.date.getMonth()] + ' ' + m.date.getFullYear()
      );
      const forecastLabels = forecast.map(f => 
        monthNames[f.date.getMonth()] + ' ' + f.date.getFullYear()
      );
      
      charts.forecast = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [...historicalLabels, ...forecastLabels],
          datasets: [
            {
              label: 'Historical Sales',
              data: [...historical.map(m => m.revenue), ...new Array(forecast.length).fill(null)],
              borderColor: '#2c3e50',
              backgroundColor: 'rgba(44, 62, 80, 0.1)',
              borderWidth: 3,
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Forecasted Sales',
              data: [...new Array(historical.length).fill(null), ...forecast.map(f => f.predicted)],
              borderColor: '#1abc9c',
              backgroundColor: 'rgba(26, 188, 156, 0.1)',
              borderWidth: 3,
              borderDash: [5, 5],
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Upper Bound',
              data: [...new Array(historical.length).fill(null), ...forecast.map(f => f.upper)],
              borderColor: 'rgba(26, 188, 156, 0.3)',
              borderWidth: 1,
              borderDash: [2, 2],
              fill: false,
              pointRadius: 0
            },
            {
              label: 'Lower Bound',
              data: [...new Array(historical.length).fill(null), ...forecast.map(f => f.lower)],
              borderColor: 'rgba(26, 188, 156, 0.3)',
              borderWidth: 1,
              borderDash: [2, 2],
              fill: false,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true, position: 'top' },
            tooltip: {
              callbacks: {
                label: (context) => context.dataset.label + ': KSH ' + formatNumber(context.parsed.y)
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { callback: (value) => 'KSH ' + (value / 1000).toFixed(0) + 'K' }
            }
          }
        }
      });
    }
    
    function renderSeasonalityChart(historical) {
      const ctx = document.getElementById('seasonalityChart');
      if (charts.seasonality) charts.seasonality.destroy();
      
      const monthlyAvg = {};
      historical.forEach(m => {
        const month = m.date.getMonth();
        if (!monthlyAvg[month]) monthlyAvg[month] = { total: 0, count: 0 };
        monthlyAvg[month].total += m.revenue;
        monthlyAvg[month].count += 1;
      });
      
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const data = monthNames.map((_, i) => 
        monthlyAvg[i] ? monthlyAvg[i].total / monthlyAvg[i].count : 0
      );
      
      charts.seasonality = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: monthNames,
          datasets: [{
            label: 'Average Sales',
            data: data,
            backgroundColor: 'rgba(52, 152, 219, 0.7)',
            borderColor: 'rgba(52, 152, 219, 1)',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: (context) => 'KSH ' + formatNumber(context.parsed.y) } }
          },
          scales: {
            y: { beginAtZero: true, ticks: { callback: (value) => 'KSH ' + (value / 1000).toFixed(0) + 'K' } }
          }
        }
      });
    }
    
    function renderTrendChart(historical, forecast) {
      const ctx = document.getElementById('trendChart');
      if (charts.trend) charts.trend.destroy();
      
      const allData = [...historical, ...forecast];
      const revenues = historical.map(m => m.revenue);
      const trend = calculateLinearTrend(revenues);
      const trendLine = allData.map((_, i) => trend.slope * i + trend.intercept);
      
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const labels = allData.map(m => monthNames[m.date.getMonth()]);
      
      charts.trend = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Actual',
              data: [...revenues, ...new Array(forecast.length).fill(null)],
              borderColor: '#2c3e50',
              borderWidth: 2,
              pointRadius: 3
            },
            {
              label: 'Trend Line',
              data: trendLine,
              borderColor: '#e74c3c',
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: true } },
          scales: {
            y: { beginAtZero: true, ticks: { callback: (value) => 'KSH ' + (value / 1000).toFixed(0) + 'K' } }
          }
        }
      });
    }
    
    function renderTopProductsChart() {
      const ctx = document.getElementById('topProductsChart');
      if (charts.topProducts) charts.topProducts.destroy();
      
      const productSales = {};
      forecastData.salesDetails.forEach(detail => {
        const item = detail.item_name;
        productSales[item] = (productSales[item] || 0) + (parseFloat(detail.total_sales_price) || 0);
      });
      
      const top5 = Object.entries(productSales)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      charts.topProducts = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: top5.map(p => p[0]),
          datasets: [{
            label: 'Sales Revenue',
            data: top5.map(p => p[1]),
            backgroundColor: 'rgba(155, 89, 182, 0.7)',
            borderColor: 'rgba(155, 89, 182, 1)',
            borderWidth: 2
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: { callbacks: { label: (context) => 'KSH ' + formatNumber(context.parsed.x) } }
          }
        }
      });
    }
    
    function renderCategoryChart() {
      const ctx = document.getElementById('categoryChart');
      if (charts.category) charts.category.destroy();
      
      const categorySales = {};
      forecastData.salesDetails.forEach(detail => {
        const cat = detail.item_category || 'Unknown';
        categorySales[cat] = (categorySales[cat] || 0) + (parseFloat(detail.total_sales_price) || 0);
      });
      
      charts.category = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: Object.keys(categorySales),
          datasets: [{
            data: Object.values(categorySales),
            backgroundColor: [
              'rgba(26, 188, 156, 0.8)',
              'rgba(52, 152, 219, 0.8)',
              'rgba(155, 89, 182, 0.8)',
              'rgba(230, 126, 34, 0.8)',
              'rgba(231, 76, 60, 0.8)',
              'rgba(243, 156, 18, 0.8)'
            ],
            borderWidth: 2,
            borderColor: '#ffffff'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'bottom' },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const pct = ((context.parsed / total) * 100).toFixed(1);
                  return `${context.label}: KSH ${formatNumber(context.parsed)} (${pct}%)`;
                }
              }
            }
          }
        }
      });
    }
    
    function generateInsights(historical, forecast) {
      const insights = [];
      
      const growthRates = [];
      for (let i = 1; i < historical.length; i++) {
        const rate = ((historical[i].revenue - historical[i-1].revenue) / historical[i-1].revenue) * 100;
        if (isFinite(rate)) growthRates.push(rate);
      }
      const avgGrowth = growthRates.length > 0 ? growthRates.reduce((a, b) => a + b, 0) / growthRates.length : 0;
      
      if (avgGrowth > 5) {
        insights.push({
          type: 'success',
          title: 'Strong Growth Trajectory',
          text: `Sales are growing at ${avgGrowth.toFixed(1)}% per month. Consider increasing inventory levels to meet expected demand.`
        });
      } else if (avgGrowth < -5) {
        insights.push({
          type: 'warning',
          title: 'Declining Sales Trend',
          text: `Sales are declining at ${Math.abs(avgGrowth).toFixed(1)}% per month. Review pricing strategy and marketing efforts.`
        });
      }
      
      const nextMonthPrediction = forecast[0]?.predicted || 0;
      const lastMonthActual = historical[historical.length - 1]?.revenue || 0;
      const expectedChange = ((nextMonthPrediction - lastMonthActual) / lastMonthActual) * 100;
      
      if (Math.abs(expectedChange) > 10) {
        insights.push({
          type: 'info',
          title: 'Significant Change Expected',
          text: `Next month's sales are predicted to ${expectedChange > 0 ? 'increase' : 'decrease'} by ${Math.abs(expectedChange).toFixed(1)}%. Plan inventory accordingly.`
        });
      }
      
      const lowStockItems = forecastData.inventory.filter(item => item.reorderRequired === 'YES');
      if (lowStockItems.length > 0) {
        insights.push({
          type: 'warning',
          title: 'Stock Replenishment Needed',
          text: `${lowStockItems.length} items are below reorder level. Replenish stock to avoid stockouts during forecasted sales periods.`
        });
      }
      
      const peakMonth = forecast.reduce((max, curr) => 
        curr.predicted > max.predicted ? curr : max, forecast[0]);
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      
      insights.push({
        type: 'info',
        title: 'Peak Sales Period Identified',
        text: `${monthNames[peakMonth.date.getMonth()]} is expected to be your peak sales month with KSH ${formatNumber(peakMonth.predicted)} in revenue.`
      });
      
      if (historical.length < 6) {
        insights.push({
          type: 'warning',
          title: 'Limited Historical Data',
          text: `Only ${historical.length} months of data available. Forecast accuracy will improve as more historical data accumulates (recommended: 12+ months).`
        });
      }
      
      return insights;
    }
    
    function displayInsights(insights) {
      const container = document.getElementById('insightsContainer');
      
      if (insights.length === 0) {
        container.innerHTML = '<div class="no-data-message"><p>No specific insights available</p></div>';
        return;
      }
      
      container.innerHTML = insights.map(insight => `
        <div class="insight-card ${insight.type}">
          <div class="insight-title">
            <i class="fas ${insight.type === 'success' ? 'fa-check-circle' : insight.type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle'}"></i>
            ${insight.title}
          </div>
          <div class="insight-text">${insight.text}</div>
        </div>
      `).join('');
    }
    
    function populateForecastTable(forecast) {
      const tbody = document.getElementById('forecastTableBody');
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
      tbody.innerHTML = forecast.map(f => {
        const confidenceBadge = f.confidence >= 70 ? 'high' : f.confidence >= 50 ? 'medium' : 'low';
        const action = f.confidence >= 70 ? 'Stock up' : f.confidence >= 50 ? 'Monitor closely' : 'Tentative planning';
        
        return `
          <tr>
            <td>${monthNames[f.date.getMonth()]} ${f.date.getFullYear()}</td>
            <td>KSH ${formatNumber(f.predicted)}</td>
            <td>KSH ${formatNumber(f.lower)}</td>
            <td>KSH ${formatNumber(f.upper)}</td>
            <td>
              <span class="accuracy-badge ${confidenceBadge}">${f.confidence}%</span>
            </td>
            <td>${action}</td>
          </tr>
        `;
      }).join('');
    }
    
    function showNoDataMessage() {
      document.querySelector('.metrics-grid').innerHTML = `
        <div class="no-data-message" style="grid-column: 1 / -1;">
          <i class="fas fa-chart-line"></i>
          <h3>No Historical Sales Data</h3>
          <p>Start making sales to enable forecasting and analytics</p>
        </div>
      `;
    }
    
    function exportForecast() {
      alert('Export functionality: Generate a CSV/PDF report with forecast data, charts, and insights. This would be implemented as a backend endpoint.');
    }

    // ADDITIONAL FUNCTION FOR SIMULATION
    function simulateScenario(baselineForecast, scenario) {
    let adjustment = 1.0;
    
    if (scenario.priceChange) {
        // Price elasticity: -10% price = +15% demand
        adjustment *= (1 + (scenario.priceChange * -1.5));
    }
    
    if (scenario.marketingSpend) {
        // Marketing ROI: +$1K spend = +5% sales
        adjustment *= (1 + (scenario.marketingSpend / 1000) * 0.05);
    }
    
    return baselineForecast.map(f => f * adjustment);
}
    
    console.log('âœ… Sales Forecasting Module Ready!');
  </script>
</body>
</html>